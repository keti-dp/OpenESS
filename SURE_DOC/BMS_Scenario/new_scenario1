#include "main.h"
#include "cmsis_os.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include "cpu_utils.h"
#include "FreeRTOS.h"
#include "task.h"

/* task's priority */

extern ADC_HandleTypeDef hadc1;
extern UART_HandleTypeDef huart2;
extern UART_HandleTypeDef huart4;

/* The task functions. */
static void MCU_Temperature(void);
static void Memory_func(uint32_t memory_size);
static void Calc_func(uint32_t parameter);
static void GPIO_func(uint32_t parameter);
static void TxDataTrans();
//static void measureTaskCPUUsage(void);

//TaskHandle_t TX_xHandle1, TX_xHandle2, TX_xHandle3;
extern volatile unsigned long ulHighFrequencyTimerTicks;
//extern volatile unsigned long task1_Percentage;
extern volatile double task1_Percentage;
extern volatile double task2_Percentage;
extern volatile double task3_Percentage;
extern UBaseType_t stack_value;
extern uint32_t heapvalue_max;
extern uint32_t heapvalue_current;
extern RNG_HandleTypeDef hrng;
extern uint8_t sc_flag[2];

uint32_t monitor_start_tick=0;
uint32_t monitor_end_tick=0;
uint32_t Normal_start_tick=0;
uint32_t Normal_end_tick=0;
uint32_t Switching_start_tick=0;
uint32_t Switching_end_tick=0;
uint32_t GPIO_start_tick=0;
uint32_t GPIO_end_tick=0;

uint32_t monitor_ticktime=0;
uint32_t Normal_ticktime=0;
uint32_t Switching_ticktime=0;
uint32_t GPIO_ticktime=0;

uint32_t temp=0;
uint32_t* arr = 0;
uint32_t delay_random = 0;
uint32_t malloc_random=0;
float adc, temperature;
typedef unsigned long UBaseType_t;

extern double cpu_usage;
extern uint32_t heapvalue_current; //230608 HWANG
extern uint32_t heapvalue_max;

//230626 HWANG
TaskStatus_t taskStatusArray[4];
//int numberOfTasks =(int)uxTaskGetNumberOfTasks();
//const int maxTasksToCheck = 3;
uint32_t taskcpuarr[4]={0,};
float cpu_usg=0;
uint32_t rand10=0;

//230616 HWANG
extern uint8_t tx_data[32];
uint8_t sce_flag=0;

uint32_t normal_random_parameter=0;
uint32_t switch_random_parameter=0;
uint32_t multifunction_random_parameter=0;

uint32_t random_arr=0;
uint32_t switch_random=0;
uint32_t gpio_switch_random=0;

uint8_t func_number=0;
uint8_t  memory_func_class = 0;
uint8_t  calc_func_class = 0;
uint8_t  gpio_func_class = 0;
uint16_t normal_task_classification = 0;
uint16_t switching_task_classification = 0;
uint16_t multifunction_task_classification = 0;

uint8_t normal_task_class = 0;
uint8_t switching_task_class = 0;
uint8_t multifunction_task_class = 0;

typedef struct error
{
	float error;
	float sum;
}Pi_Errors;
typedef struct gain
{
	float P;
	float I;
}Pi_Gains;

Pi_Errors error_test;
Pi_Gains gain_test;

static float f32_Asw_PiController(float f32_ref, float f32_in, Pi_Errors enp_error, Pi_Gains en_K); //230616 HWANG;
uint32_t cpu_usage_test =0;

uint32_t usage =0;
float cpu_usagetest=0.0f;
uint32_t Normal_TASK_priority =0;
uint32_t Switching_TASK_priority =0;
uint32_t GPIO_TASK_priority =0;
uint8_t task_random=0;
#define KIY

osThreadId TaskHandle;
osThreadId TaskHandle1;
osThreadId TaskHandle2;
osThreadId TaskHandle3;
osThreadId TaskHandle4;


void Monitor_TASK(void const * argument)//monitor
{
    while(1)
    {
    	monitor_start_tick = xTaskGetTickCount();

    	task_random =(HAL_RNG_GetRandomNumber(&hrng)%7);

        //measureTaskCPUUsage();
        usage = osGetCPUUsage();
		heapvalue_current = xPortGetFreeHeapSize();
		heapvalue_max = xPortGetMinimumEverFreeHeapSize();
		MCU_Temperature();

//		test
//		printf("\ncpu usage : %d\n",usage);
//		printf("stack usage : %d\n",stack_value);
//		printf("heap current usage : %d\n",heapvalue_current);
//		printf("heap value usage : %d\n",heapvalue_max);
//		printf("func number : %d\n",func_number);

		TxDataTrans();
		monitor_end_tick = xTaskGetTickCount();
		monitor_ticktime = monitor_end_tick - monitor_start_tick;
		osDelay(100);

		//usage = osGetCPUUsage();
		//cpu_usagetest = (((float)monitor_ticktime + (float)Normal_ticktime + (float)Switching_ticktime + (float)GPIO_ticktime) / 3000.0 * 4 ) * 100;

    }
}

void Normal_TASK(void const * argument)
{
	while(1)
	{
		Normal_start_tick = xTaskGetTickCount();
		normal_random_parameter = (((HAL_RNG_GetRandomNumber(&hrng)%100)+1)*100);

		if(normal_task_classification < 500)
		{
			Memory_func(normal_random_parameter);
			Calc_func(normal_random_parameter);
			GPIO_func(normal_random_parameter);
			normal_task_classification++;
		}
		else
		{
			Memory_func(normal_random_parameter);
			for(int i=0;i<50; i++)
			{
				Calc_func(normal_random_parameter);
			}
			GPIO_func(normal_random_parameter);
			normal_task_classification = 0;
		}
		//vTaskPrioritySet(TaskHandle1, task_random);
		//Normal_TASK_priority = uxTaskPriorityGet(TaskHandle1);

		osDelay(200);

		Normal_end_tick = xTaskGetTickCount();
		Normal_ticktime = Normal_end_tick - Normal_start_tick;
	}
}

static void Switching_TASK(void const * argument)
{
    while(1)
    {
    	Switching_start_tick = xTaskGetTickCount();
#if 1
    	switch_random_parameter = (((HAL_RNG_GetRandomNumber(&hrng)%100)+1)*100);

		//switch_random=(HAL_RNG_GetRandomNumber(&hrng)%3);
    	if(switch_random < 3)
		{
    		switch_random++;
		}
    	else
    	{
    		switch_random=0;
    	}

    	if(switching_task_classification < 500)
    	{
			switch(switch_random)
			{
				case 0:
					Memory_func(switch_random_parameter);
					break;
				case 1:
					Calc_func(switch_random_parameter);
					break;
				case 2:
					GPIO_func(switch_random_parameter);
					break;
				default:
					break;
			}
			switching_task_classification++;
    	}

		else
		{
			switch(switch_random)
			{
				case 0:
					Memory_func(switch_random_parameter);
					break;
				case 1:
			    	for(int i=0;i<100; i++)
			    	{
			    		Calc_func(switch_random_parameter);
			    	}
			    	break;
				case 2:
					GPIO_func(switch_random_parameter);
					break;
				default:
					break;
			}
			switching_task_classification = 0;
		}

    	osDelay(100);
    	Switching_end_tick = xTaskGetTickCount();
    	Switching_ticktime = Switching_end_tick - Switching_start_tick;
    }
    	//vTaskPrioritySet(TaskHandle2, task_random);
    	//Switching_TASK_priority = uxTaskPriorityGet(TaskHandle2);
#endif


}


void Multifunction_TASK(void const * argument)
{
	//random_parameter = (HAL_RNG_GetRandomNumber(&hrng)%10);

    while(1)
    {
    	GPIO_start_tick = xTaskGetTickCount();
#if 1
    	multifunction_random_parameter = (((HAL_RNG_GetRandomNumber(&hrng)%100)+1)*100);

    	if(multifunction_task_classification < 500)
        {
			Memory_func(multifunction_random_parameter);
			Calc_func(multifunction_random_parameter);
			GPIO_func(multifunction_random_parameter);

			if(gpio_switch_random<3)
			{
				gpio_switch_random++;

			}
	    	else
	    	{
	    		gpio_switch_random=0;
	    	}


			switch(gpio_switch_random)
			{
				case 0:
					Memory_func(multifunction_random_parameter);
					Calc_func(multifunction_random_parameter);
					GPIO_func(multifunction_random_parameter);
					break;
				case 1:
					Calc_func(multifunction_random_parameter);
					Memory_func(multifunction_random_parameter);
					Calc_func(multifunction_random_parameter);
					break;
				case 2:
					GPIO_func(multifunction_random_parameter);
					Memory_func(multifunction_random_parameter);
					GPIO_func(multifunction_random_parameter);
				case 3:
					Memory_func(multifunction_random_parameter);
					Calc_func(multifunction_random_parameter);
					GPIO_func(multifunction_random_parameter);
					break;
				default:
					break;
			}
			multifunction_task_classification++;
        }

		else
		{
			Memory_func(multifunction_random_parameter);
			for(int i=0;i<150; i++)
			{
				Calc_func(multifunction_random_parameter);
			}
			GPIO_func(multifunction_random_parameter);

			if(gpio_switch_random<3)
			{
				gpio_switch_random++;
			}

			switch(gpio_switch_random)
			{
				case 0:
					Memory_func(multifunction_random_parameter);
					Calc_func(multifunction_random_parameter);
					GPIO_func(multifunction_random_parameter);
					break;
				case 1:
					Calc_func(multifunction_random_parameter);
					Memory_func(multifunction_random_parameter);
					Calc_func(multifunction_random_parameter);
					break;
				case 2:
					GPIO_func(multifunction_random_parameter);
					Memory_func(multifunction_random_parameter);
					GPIO_func(multifunction_random_parameter);
				case 3:
					Memory_func(multifunction_random_parameter);
					Calc_func(multifunction_random_parameter);
					GPIO_func(multifunction_random_parameter);
					break;
				default:
					break;
			}
			multifunction_task_classification=0;

		}
        osDelay(100);

		GPIO_end_tick = xTaskGetTickCount();
		GPIO_ticktime = GPIO_end_tick - GPIO_start_tick;
		//vTaskPrioritySet(TaskHandle3, task_random);
	   // GPIO_TASK_priority = uxTaskPriorityGet(TaskHandle3);
#endif
    }
}

void TxDataTrans()
{
	memset(tx_data, 0, sizeof(tx_data));

	tx_data[0] = usage;
	tx_data[1] = stack_value >> 8;
	tx_data[2] = stack_value;
	tx_data[3] = heapvalue_current >> 8;
	tx_data[4] = heapvalue_current;
	tx_data[5] = heapvalue_max >> 8;
	tx_data[6] = heapvalue_max;
	tx_data[7] = temp >> 8;
	tx_data[8] = temp;
	tx_data[9] = func_number;

	HAL_UART_Transmit_DMA(&huart2, (uint8_t*)tx_data, sizeof(tx_data));
}

void Memory_func(uint32_t memory_size)
{
	func_number = 1;
	static uint8_t memory_flag = 0;
	static uint8_t *memory_ptr;

	if(memory_func_class == 0)
	{

		if(memory_flag == 0)
		{
			memory_ptr = pvPortMalloc(sizeof(uint8_t)*memory_size);
			memory_flag = 1;
		}
		else if(memory_flag == 1)
		{
			vPortFree((uint8_t*)memory_ptr);
			memory_flag = 0;
		}
	}
#if 0
	else if(memory_func_class == 1) //추후 추가
	{

	}
#endif
}

void Calc_func(uint32_t calc_parameter)
{

	func_number = 2;
    static uint32_t KIY_test_cnt2 = 0;
    static uint32_t KIY_test_cnt3 = 0;
	float random_test=0.f;

	if(calc_func_class == 0)
	{
		random_test = ((HAL_RNG_GetRandomNumber(&hrng)%3)+1)*10;
		random_arr = (HAL_RNG_GetRandomNumber(&hrng)%20);

		volatile float arr[random_arr];

		for(int i=0; i<random_arr; i++)
		{
			arr[i] = random_arr;
		}

		for(int i=0;i<calc_parameter;i++)
		{
			f32_Asw_PiController(random_test,(random_test+1),error_test,gain_test);
		}
	}
#if 0
	else if(calc_func_class == 1)//추후 추가
	{

	}
#endif
}

void GPIO_func(uint32_t gpio_parameter)
{
	func_number = 3;

	if(gpio_func_class == 0)
	{
		for(int i=0;i<gpio_parameter;i++)
		{
			HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_12);
			HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13);
			HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_14);
			HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_15);
		}
	}
#if 0
	else if(gpio_func_class==1)//추후 추가
	{

	}
#endif
}

static float f32_Asw_PiController(float f32_ref, float f32_in, Pi_Errors enp_error, Pi_Gains en_K)
{
	float out = 0.f;
	en_K.P = HAL_RNG_GetRandomNumber(&hrng);
	en_K.I = HAL_RNG_GetRandomNumber(&hrng);

	enp_error.error = f32_ref - f32_in;
	enp_error.sum += enp_error.error;
	out = (en_K.P * enp_error.error) + (en_K.I * enp_error.sum);

	return out;
}

static void MCU_Temperature()
{
	HAL_ADC_Start(&hadc1);
	HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);

	adc = HAL_ADC_GetValue(&hadc1);
	temperature = adc * 3.3 / 0xfff;
	temperature = (temperature-0.76)/0.025 + 25.0;
	temp = temperature*10;
}




#if 0
void measureTaskCPUUsage()
{
    static const TickType_t measurementPeriod = pdMS_TO_TICKS(1000);
    static TickType_t lastMeasurementTime = 0;
    //unsigned portBASE_TYPE uxArraySize1 = 4;

    unsigned portBASE_TYPE uxArraySize1=uxTaskGetNumberOfTasks();

    TaskStatus_t taskStatusArray[uxArraySize1];

    if (xTaskGetTickCount() - lastMeasurementTime >= measurementPeriod)
    {
        lastMeasurementTime = xTaskGetTickCount();

        uint32_t totalRunTime;
        const unsigned portBASE_TYPE actualTasks = uxTaskGetSystemState(&taskStatusArray[0], uxArraySize1, &totalRunTime);//

        for (unsigned portBASE_TYPE i = 0; i < actualTasks; i++)
        {
            const TaskStatus_t *taskStatus = &taskStatusArray[i];

            uint32_t taskRunTime = taskStatus->ulRunTimeCounter;
            uint32_t taskRunCount = taskStatus->ulRunTimeCounter / portTICK_PERIOD_MS;

            float cpuUsage = (float)(taskRunTime * 100) / (totalRunTime * taskRunCount);

            //taskcpuarr[i]=(float)(taskRunTime * 100) / (totalRunTime * taskRunCount);
        }
    }
}
#endif



/*-----------------------------------------------------------*/

/* USER CODE BEGIN Header_StartMyTask1 */
/**
  * @brief  Function implementing the MyTask1 thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartMyTask1 */
void StartMyTask1(void const * argument)
{
  /* USER CODE BEGIN 5 */
  /* Infinite loop */

  osThreadDef(KiyTask, Monitor_TASK, osPriorityNormal, 0, 256);
  TaskHandle = osThreadCreate(osThread(KiyTask), NULL);

  osThreadDef(KiyTask1,Normal_TASK, osPriorityNormal, 0, 256);
  TaskHandle1 = osThreadCreate(osThread(KiyTask1), NULL);

#if 1
  osThreadDef(KiyTask2, Switching_TASK, osPriorityNormal, 0, 256);
  TaskHandle2 = osThreadCreate(osThread(KiyTask2), NULL);

  osThreadDef(KiyTask3, Multifunction_TASK, osPriorityNormal, 0, 256);
  TaskHandle3 = osThreadCreate(osThread(KiyTask3), NULL);
#if 0
  osThreadDef(KiyTask4, Stack_TASK, osPriorityNormal, 0, 256);
  TaskHandle4 = osThreadCreate(osThread(KiyTask4), NULL);
#endif

#endif

  while(1)
  {
      osDelay(100);
  }
}
