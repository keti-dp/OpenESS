## RLS 단일 셀 1Cycle
OCV_6S2P = loadmat('D:/내 과제/한국전자기술연구원/매트랩 코드/OCV_6S2P')
OCV = loadmat('D:/내 과제/한국전자기술연구원/매트랩 코드/OCV.mat')['OCV'].flatten()

SOC = np.linspace(1, 0, num=21)

overch_6S2P_ch_cell_vol = pd.read_csv('D:/내 과제/한국전자기술연구원/매트랩 코드/.csv/overch_6S2P_ch_cell_vol.csv')
overch_6S2P_ch_cell_cur = pd.read_csv('D:/내 과제/한국전자기술연구원/매트랩 코드/.csv/overch_6S2P_ch_cell_cur.csv')

Volin = overch_6S2P_ch_cell_vol
Curin = overch_6S2P_ch_cell_cur

Time = 1
Init_cap = 3.35
Init_Ri = 0.0300309229305423
Init_Rdiff = 0.029803520456708
Init_Cdiff = 6.910040511506387e+04
ErrorCovariance = np.matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
ForgettingFactor = 0.99

Vector_b0 = Init_Ri
Vector_b1 = (-Init_Ri + 1 / Init_Cdiff + Init_Ri / (Init_Rdiff * Init_Cdiff))
Vector_a1 = (1 / (Init_Rdiff * Init_Cdiff) - 1)

# zip함수: dict(zip(SOC, OCV))는 SOC가 키 값이고 OCV는 키에 해당하는 값이므로 SOC가 x축, OCV가 y축
SOC_OCV_lookup = dict(zip(SOC, OCV))
OCV_SOC_lookup = dict(zip(OCV, SOC))

# SOC_OCV_lookup 테이블을 역으로 변환하여 SOC에 따른 OCV를 찾는 Lookup table 생성
sorted_SOC_OCV_lookup = sorted(SOC_OCV_lookup.items())
sorted_OCV_SOC_lookup = sorted(OCV_SOC_lookup.items())

def find_soc_from_voltage(voltage, lookup_table):
    ocvs, socs = zip(*lookup_table)  
    ocvs = np.array(ocvs)
    socs = np.array(socs)

    if voltage < ocvs.min():
        slope = (socs[1] - socs[0]) / (ocvs[1] - ocvs[0])
        extrapolated_soc = socs[0] + slope * (voltage - ocvs[0])
    elif voltage > ocvs.max():
        slope = (socs[-1] - socs[-2]) / (ocvs[-1] - ocvs[-2])
        extrapolated_soc = socs[-1] + slope * (voltage - ocvs[-1])
    else:
        extrapolated_soc = np.interp(voltage, ocvs, socs)
    
    return extrapolated_soc

def find_ocv_from_soc(soc, lookup_table):
    socs, ocvs = zip(*lookup_table)  
    socs = np.array(socs)
    ocvs = np.array(ocvs)

    if soc < socs.min():
        slope = (ocvs[1] - ocvs[0]) / (socs[1] - socs[0])
        extrapolated_ocv = ocvs[0] + slope * (soc - socs[0])
    elif soc > socs.max():
        slope = (ocvs[-1] - ocvs[-2]) / (socs[-1] - socs[-2])
        extrapolated_ocv = ocvs[-1] + slope * (soc - socs[-1])
    else:
        extrapolated_ocv = np.interp(soc, socs, ocvs)
    
    return extrapolated_ocv

# Initial SOC calculation from voltage
Init_soc_overch_6S2P_ch_cell = [find_soc_from_voltage(vol, sorted_OCV_SOC_lookup) for vol in Volin.iloc[:, 0]]

# Ah counting to calculate SOC
SOC_ref_overch_6S2P_ch_cell = []
current_SOC = Init_soc_overch_6S2P_ch_cell[0]

for i in range(len(Curin)):
    delta_SOC = (Curin.iloc[i, 0] / Init_cap) * (Time / 3600)
    current_SOC += delta_SOC
    SOC_ref_overch_6S2P_ch_cell.append(current_SOC)

OCV_overch_6S2P_ch_cell = [find_ocv_from_soc(soc, sorted_SOC_OCV_lookup) for soc in SOC_ref_overch_6S2P_ch_cell]

theta = np.array([Vector_b0, Vector_b1, Vector_a1]).reshape(-1, 1)
P = ErrorCovariance

Ri_estimates = [Init_Ri]
Rdiff_estimates = [Init_Rdiff]
Cdiff_estimates = [Init_Cdiff]

def calculate_gain_and_covariance(phi, P, forgetting_factor):
    P_phi = P @ phi
    gain_denominator = forgetting_factor + phi.T @ P @ phi 
    gain = P_phi / gain_denominator
    covariance = (P - gain @ phi.T @ P) / forgetting_factor
    covariance = np.clip(covariance, 0, 1e-15)
    return gain, covariance

gain_values = []
overpotential_values = []
RlsEstimatedVoltage_values = []
RlsVoltageError_values = []
covariance_values = []
theta_values = []
phi_values = []

for t in range(1, len(Volin)):
    voltage = Volin.iloc[t, 0]
    current = Curin.iloc[t, 0]
    prev_current = Curin.iloc[t-1, 0]
    ocv = OCV_overch_6S2P_ch_cell[t]

    overpotential = ocv - voltage
    overpotential_values.append(overpotential)

    phi = np.array([current, prev_current, overpotential]).reshape(-1, 1)
    phi_values.append(phi.flatten())

    RlsEstimatedVoltage = theta.T @ phi
    RlsEstimatedVoltage_values.append(RlsEstimatedVoltage[0, 0])

    RlsVoltageError = voltage - ocv - RlsEstimatedVoltage
    RlsVoltageError_values.append(RlsVoltageError[0, 0])

    P = covariance

    gain, covariance = calculate_gain_and_covariance(phi, P, ForgettingFactor)
    gain_values.append(gain.flatten())
    covariance_values.append(covariance.flatten())

    
    theta = theta + gain @ RlsVoltageError
    theta = np.abs(theta)
    theta_values.append(theta.flatten())

    Ri = theta[0, 0]
    Rdiff = (theta[1, 0] - theta[2, 0] * theta[0, 0]) / (1 - theta[2, 0])
    Cdiff = 1 / (theta[1, 0] - theta[2, 0] * theta[0, 0])

    Ri = np.abs(Ri)
    Rdiff = np.abs(Rdiff)
    Cdiff = np.abs(Cdiff)

    Ri_estimates.append(Ri)
    Rdiff_estimates.append(Rdiff)
    Cdiff_estimates.append(Cdiff)

gain_values = np.array(gain_values).reshape(-1, 3)
covariance_values = np.array(covariance_values).reshape(-1, 9)  # 3x3 matrix flattened
theta_values = np.array(theta_values).reshape(-1, 3)
phi_values = np.array(phi_values).reshape(-1, 3)
